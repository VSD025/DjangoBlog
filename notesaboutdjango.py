
'''
mkdir folder_name
python -m venv 'myvenv' - 1создание виртуального окружения (создается папка, вкоторой есь только стандартные модули python)
myvenv\Scripts\activate - активируем созданное виртуальное пространство
pip install django - в нужном репозитории
django-admin startproject mysite . - созадние нового проекта django - точка текущая папка
python manage.py migrate - выполнение миграций, а именно:  Apply all migrations: admin, auth, contenttypes, sessions, а также создание базы данных
python manage.py runserver - запуск локального сервера
python manage.py startapp blog - создание отдельного приложения в нашей папке и в нашем виртуальном пространстве
При этом создается отдельная папка для приложения, чтобы его активировать, нужно перйти в корневуб папку проекта (mysite) и в настройках добавить в поле
приложений наше приложение
python manage.py makemigrations blog - подключение приложения к проекту 
python manage.py migrate blog - добавление данных в БД 
python manage.py createsuperuser


git init - инициализация git
git add --all - добавление в git всех имеющихся файлов
git commit -m "My django app" - добавление в git функционала проекта

Последующие комманды проязводтся в папке нашего проекта, НО НЕ В ВИРТУАЛЬНОМ ОКРУЖЕНИИ:
git remote add origin https://github.com/VsevolodS23/my-first-blog.git
git push -u origin master


Инструкция по использованию системы контроля версий(git):
git init - инициализация системы контроля версий (в необходимой папке)
Подключение к GitHub(у):
git remote add origin https://github.com/VsevolodS23/nr.git
git push -u origin master - push добавляет журнал коммитов в удаленный репозиторий


git status - показывает незаписанные изменения файлов и новые файлы
git add . - добавляет все файлы в git (можно использовать и для одного фйла с указанием имени)
git commit -m "First commit" - обязательно двойные скобки (с комментарием)
commit(ы) сохраняются в git(е) и синхронизируются с Git Hub(ом)
git push - добавление изменений в удаленный репозиторий (работает со 2 раза) т.к первый  = git push -u origin master


Клонирование чужого репозитория:
git clone https://github.com/Dementiy/Dementiy.github.io.git


Создание виртуального окружения: (2 способа)

1)С помощью библиотеки virtualenv
python -m venv 'myvenv' - создание виртуального окружения (создается папка, вкоторой есь только стандартные модули python)
myvenv\Scripts\activate - активируем созданное виртуальное пространство

2)С помощью библиотеки virtualenvwrapper-win
mkvirtualenv cs102
workon cs102
'''




'''
РАЗЛИЧНЫЕ ТЕОРИТИЧЕСКИЕ ПОНЯТИЯ
Фреймворк - это набор компонентов, которые помогают разрабатывать веб-сайты быстро и просто
При разработке веб-сайтов очень часто возникают однотипные проблемы ( способ аутентифицировать пользователей (вход, выход, регистрация),
панель управления сайтом, формы, инструменты для загрузки файлов),которые решаются в фреймворках путем создания шаблонов

Основная задача Фреймворка - Сервер должен узнать о том, что мы ждем от него веб-страницу. Определенный порт сервера проверяется на наличие запросов, как
приходит запрос Джанго формирует контент для отправки ответа. Когда на сервер приходит запрос, он переадресуется Django,который для начала берет адрес
веб-страницы и пробует понять -- что же нужно сделать. Эту часть процесса в Django выполняет urlresolver (адрес веб-сайта называется URL - Uniform Resource Locator
Единый указатель ресурсов, так что название urlresolver, resolver == определитель, имеет определенный смысл). Он не слишком умен, поэтому просто берет список 
шаблонов и пытается сопоставить их с URL. Django сверяет шаблоны сверху вниз и, если что-то совпадает, он переправляет запрос соответствующей функции 
(которая называется view).

django-admin startproject mysite . Создает древовидную иерархию файлов такого типа:

my-first-blog
├───manage.py
└───mysite
        settings.py
        urls.py
        wsgi.py
        __init__.py


Файл urls.py содержит список шаблонов, по которым ориентируется urlresolver
Модель в Django это объект определенного свойства - он хранится в базе данных

python manage.py startapp blog - создает новое Джанго приложение, которое нам нужно подключить к нашему проекту через settings.py в mysite, тем самым подключим
приложение к нашему проекту

djangogirls
├── mysite
|       __init__.py
|       settings.py
|       urls.py
|       wsgi.py
├── manage.py
└── blog
    ├── migrations
    |       __init__.py
    ├── __init__.py
    ├── admin.py
    ├── models.py
    ├── tests.py
    └── views.py

Теперь в blog/Models мы можем создавать модели и методы, которые будем подключать к нашему проекту через комманду:
python manage.py makemigrations blog - тем самым добавляя эту модель в базу данных

Чтобы иметь права администратора на модели Джанго мы должны подключить нашу модель к админке в blog/admin.py:

from django.contrib import admin
from .models import Post

admin.site.register(Post) - Подключение модели

Любая страница в Интернете нуждается в собственном URL-адресе. Таким образом ваше приложение точно знает, что показать пользователю, который
открывает конкретный URL-адрес. В Django мы используем кое-что под названием URLconf (англ. URL configuration, конфигурация URL).
URLconf — это набор шаблонов, которые Django попробует сравнить с полученным URL, чтобы выбрать правильный метод для отображения (view).
В данном моменте идет речь о работе URL resolver'а


Работа url resolvera происходит в файле mysite/urls.py
Данный фаил имеет примерно такой вид:

from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    # Examples:
    # url(r'^$', 'mysite.views.home', name='home'),
    # url(r'^blog/', include('blog.urls')),

    url(r'^admin/', include(admin.site.urls)),
]

В urlpatterns происходит работа urlresolver'а. Полученный портом URL адрес прогоняется по шаблонам, указанным в urlpatterns 
Таким образом, любому URL-адресу, начинающемуся с admin/, Django будет находить соответствующее view (представление). В этом случае мы охватываем
большое множество различных URL-адресов, которые явно не прописаны в этом маленьком файле -- так он становится более аккуратным и удобочитаемым.

Процесс сопоставления URL адресов происходит с помошью так называемые регулярных выражений (англ. "regular expressions" — сокращённо regex). 
Регулярные выражения имеют множество (множество!) правил, которые формируют поисковый шаблон.
Шаблоны имеют такой синтаксис:
^ начало текста
$ конец текста
\d цифра
+ предыдущий пункт должен быть повторен как минимум один раз
() часть шаблона


Допустим у нас есть веб-сайт с адресом http://www.mysite.com/post/12345/, где 12345 номер записи в блоге(id поста)
Писать представления для всех номеров будет весьма утомительно. С помощью регулярных же выражений мы можем создать шаблон, соответствующий url,
который позволит извлекать из адреса номер: ^post/(\d+)/$. Давай разобьём шаблон на части, чтобы понять его логику:
    ^post/ говорит Django рассматривать url с post/ в начале (сразу после ^)
    (\d+) означает, что дальше должен присутствовать номер (одна или несколько цифр) и мы хотим извлечь его из url
    / говорит Django об очередном символе / после номера
    $ означает конец url, т.е. шаблону соответствуют только адреса с / на конце


Теперь мы хотим создать домашнюю страницу для нашего блога, чтобы на ней отображались все имеющиеся у нас посты:
Сначала подключаем еще несозданный фаил blog.urls к mysite/urls с помощью строчки такого вида:
url(r'', include('blog.urls')), -  в регулярных выражениях, r в начале строки, полезный намек для Python, что строка может содержать специальные символы, предназначенные не для самого Python, 
а для регулярного выражения.

Затем создаем фаил blog/urls.py
И добавляем туда метод post_list вместе с urlpatterns для данного метода, указывая переадресацию с urls в mysite

Шаблон -- это файл, который мы можешь использовать повторно для отображения различной информации в заданном формате, например,
ты можешь использовать шаблон, чтобы упростить написание письма, поскольку письма хоть и различаются по содержанию и получателю, но сохраняют общую структуру.

Настройка html шаблона просходит путем создания директори:
blog
└───templates
    └───blog

И создание в последней из них шаблонов в виде html кода:
head -- это элемент, содержащий информацию о документе, которая не отображается на экране.
body -- это элемент, который содержит все, что будет отражено на веб-странице.

    <h1>Заголовок</h1> - главный заголовок страницы
    <h2>Подзаголовок</h2> для заголовков второго уровня
    <h3>Заголовок третьего уровня</h3> ... и так далее, вплоть до <h6>
    <em>текст</em> подчеркивает твой текст
    <strong>текст</strong> - жирный шрифт
    <br /> переход на следующую строку (внутрь br тега нельзя ничего поместить)
    <a href="https://djangogirls.org">link</a> создает ссылку
    <ul><li>первый элемент</li><li>второй элемент</li></ul> создает список, такой же как этот!
    <div></div> определяет раздел страницы


python manage.py shell - вызов консоли django (используется синтаксис python) - консоль администрирования django

>>> from blog.models import Post
>>>Post.objects.all() - вызываются всех постов
Все просто: мы импортируем модель Post из blog.models. Давай попробуем получить все записи блога еще раз:

>>> Post.objects.all()
<QuerySet [<Post: my post title>, <Post: another post title>]>

Это список записей, с которыми мы работали до этого! Мы создали их через панель администратора Django. Теперь же, мы хотим создавать записи через Python, так как же мы этого добьемся?

>>> Post.objects.create(author=me, title='Sample title', text='Test')
Traceback (most recent call last):
  File "<console>", line 1, in <module>
NameError: name 'me' is not defined
>>> from django.contrib.auth.models import User
>>> User.objects.all()
<QuerySet [<User: vsevolod>]>
>>> me = User.objects.get(username = 'vsevolod')
>>> Post.objects.create(author=me, title='Sample title', text='Test')
<Post: Sample title>
>>> Post.objects.all()
<QuerySet [<Post: dds>, <Post: 3232323>, <Post: Sample title>]>

>>> Post.objects.filter(author=me)
<QuerySet [<Post: dds>, <Post: 3232323>, <Post: Sample title>]> - Можем фильтровать имеющиеся у нас объекты(посты)

>>> Post.objects.filter(title__contains='title') - А может быть мы хотим получить все записи со словом 'title' в поле title?
<QuerySet [<Post: Sample title>]>


#В КАЧЕСТВЕ ОБЪЕКТОВ ИСПОЛЬЗУЮТСЯ АТРИБУТЫ КЛАССА POST УКАЗАННЫЕ В ФАЙЛЕ BLOG/MODELS.PY


>>>Post.objects.create(author = me, title = 'Anymore', text = 'Paramore')
<Post: Anymore>
>>> post = Post.objects.get(title = 'Anymore')
>>> post.publish() - опубликование поста
>>> from django.utils import timezone
>>> Post.objects.filter(published_date__lte = timezone.now())
<QuerySet [<Post: dds>, <Post: 3232323>, <Post: Anymore>]>
>>>Post.objects.order_by('created_date')
<QuerySet [<Post: dds>, <Post: 3232323>, <Post: Sample title>, <Post: Anymore>]>


Post.objects.order_by('created_date') #Выстраивание очереди по дате публикации
<QuerySet [<Post: dds>, <Post: 3232323>, <Post: Sample title>, <Post: Anymore>]>


Можно создавать сцепки из нескольких QuerySets
Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')



Отдельные части уже размещены в нужных местах: модель Post, определена в файле models.py, post_list - в файле views.py и добавлен шаблон.
Но как нам отобразить записи в шаблоне HTML-страницы? Ведь именно этого нам и нужно добиться: взять определенный контент (модели, сохраненные в базе данных) 
и аккуратно отобразить их в шаблоне, верно?
Для этого и предназначены представления: соединять между собой модели и шаблоны. В post_list представлениям нужно будет взять модели, которые мы хотим отобразить
и передать их шаблону. Таким образом, в представлениях мы определяем что (какая модель) будет отображена в шаблоне.


Теперь нам нужно включить модель, которую мы определили в файле models.py ВКЛЮЧАЕМ В ФАЙЛЕ VIEWS.PY

В файле шаблона post_list.html пишем такой код:

{% for post in posts %}
        <div>
            <p>published: {{ post.published_date }}</p>
            <h1><a href="">{{ post.title }}</a></h1>
            <p>{{ post.text|linebreaksbr }}</p>
        </div>
    {% endfor %}

Данный код создает цикл, который проходится по всем постам. Также мы можем обращаться к переменной post(из файла blog/views), а также к атрибутам поста из файла
blog/models


Устанавливаем Bootstrap для CSS - просто добавляем ссылки на файлы из удаленных репозиториев в <head></head> - т.к то, что в данном теге не отображается.
Добавляем это в шаблон.


'''